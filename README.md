
## CPP Demo HelloWorld

## 函数
申明头文件，实现函数，对应的文件需要引入头文件

## 变量
* 宏定义(C语言中使用较多)，`.h`文件中定义，一般为全大写(如：`#define PI 3.14159`)
* 常量定义(CPP中常用)，源文件中，一般首字母大写(如：`const float Pi = 3.14159`)
* 变量定义，源文件中，一般首字母小写(如：`float pi = 3.14159`); 可以定义局部和全局变量，全局变量访问(`::pi`)
  * 全局变量可以不用初始化，编译器会帮忙初始化(如： `int a; // 会被编译器默认赋值0`)；
  * 局部变量申明后，在使用前必须初始化，所以推荐申明马上初始化(如：`int a = 10;`)

## 数据类型

### 基本数据类型
申明的时候，只是告诉编译器，申明的变量需要占用多大的空间。

#### 整型(Integer Type)
本质来讲是表示整数的类型。
在计算机中，所有数据都是以二进制0，1来表示的；每个0或1叫做一位(bit);计算机可寻址的内存最小单元是8位，也就是一个字节(Byte)。
我们访问的数据，都是保存在内存的一个个字节里面的。一个字节能表示的最大数是2^8=265。
基本整型包括char(最小8位)、short(最小16位)、int(最小16位，平台不同大小不同)、long(最小32位)，C++11新增long long(最小64位)，布尔类型(未定义，由平台确定)本质也是整型。
不过，int不能比short短，不能比long长，即int的取值范围在[short,long]；一般情况下(win7,win10,macos)，int都是32位，和long一样。

无符号整数，再前面添加unsigned int，short，long就可以。

溢出的原理，与计算机的数据表示有关，涉及到原码、反码、补码的原理。


#### 特殊整型(bool/char)
* char类型
  char：字符，最小尺寸8位(2^8=256)；ASCII编码(用0~127表示128个字符，包括大小写字母、数字、标点符号、特殊符号和一些计算机的控制符)。`char`也有`signed char`和 `unsigned char`
  wchar_t：宽字符类型，底层一般对应另一种整型(short或者int)。C++11中为Unicode字符集提供了专门的拓展字符类型，`char16_t, char32_t`.
* bool类型(真值判断)
  bool类型通常占用8位(一个字节)；取值只有`true、false`；

#### 浮点类型
* float：单精度(一般4字节32位)
* double：双精度(不能小于float，一般8字节64位)
* long double：长双精度(一般12或16个字节)

#### 字面值常量
* 整型字面量
  * 30： 十进制表示法(0-9的数字表示)
  * 036： 八进制表示法(0-7的数字表示)
  * 0x1E：十六进制表示(0-9ABCDEF表示)
  * 上面三个数都是30(十进制)的不同进制表达。
  * 036L
* 浮点字面量
  * 3.14f：float类型
  * 3.14：double类型(默认)
  * 3.14L：long double类型
* 字符(串)字面常量
  * 'C'
  * “ABC”：字符串，本质是一串字符的集合
  * 转义字符：'\''
    * 换行符 \n 
    * 回车符 \r
    * 横向制表符 \t 
    * 报警响铃符 \a 
    * 纵向制表符 \v 
    * 问号 \?
    * 退格符 \b 
    * 反斜线 \\ 
    * 进制符 \f

### 类型转换

#### 赋值时自动类型转换
* bool类型
  * bool b = 25; (底层把所有非零值转成1)
* 浮点与整型转换
  * int a = 3.14; (a = 3)
  * int a = 3.94; (a = 3) ，其实就是小数部分抹掉保留整数部分，带来精度确实
* 整型与整型
  * unsigned short us = 65536； (溢出，us = 0)

## 运算符

### 类型
一元运算符(^取反+-)；+—也可以表示正负
二元运算符(+-*/&|这种)
三元运算符(?:)

### 运算优先级与结合律
平级运算符遵循从左往右依次计算，高一级的预算先计算，和数学的综合表达式类似。
eg：复合表达式：1+2-3*4；先计算3*4=12；1+2-12；然后依次计算。
想要改变优先级，可以使用括号来实现。

### 算术运算
* +、-：正负符号，一元运算符，优先级最高
* */%：乘除取余，二元运算符，优先级次高
* +、-：加减，优先级最低

### 赋值运算符
=，
* 左边必须是可修改的变量(左值)，右边是变量或者常量或者字面量(右值)
* 常量不允许再赋值
* 两侧类型不同时，把右侧对象转换成左侧对象的类型
* 复合赋值运算符
  * 算术运算符：+=、-=、*=、/=、%=
  * 位运算符：<<=、>>=、&=、^=、!=
* 递增递减运算符(自增自减)
  * ++a; ==> a+=1
  * --a; ==> a-=1
  * a++
  * a++和++a的区别： 前置时，对象先加一，再将更新之后的对象值作为结果返回；后置时，对象先将原始值作为结果返回，再加一

### 关系和逻辑运算符

#### 关系运算符
* 大于：`>`
* 大于：`>=`
* 小于：`<`
* 小于等于：`<=`
* 相等：`==`
* 不相等：`!=`

#### 逻辑运算符
与或非
* ！：一元运算符：取反
* &&：二元，全为真才为true
* ||：二元，有一个满足即为真
> 短路求值： i = 0;
> 1<2 && ++i: => i = 1; 前面为真才会执行后面的，因为是&&，但如果前面为false，后面则不会执行
> 1<2 || ++i; => i = 0; 前面为真就直接返回，因为是||
 
### 条件运算符 
三元运算符，`?:`
```c++
  int a = 10;
  int b = 20;
  string c = "";
  
  a > b ? c = "a大于b" : c = "a小于等于b";
  
  cout << c << endl;
 ```

### 位运算符
* 位求反：~
* 左移：<< 
* 右移：>> 
* 位与：&
* 位异或：^
* 位或：|

#### 位运算符
* 左移：<< `unsigned char bit = 0xb5; // 1011 0101`
  * `bits << 2;` 先提升为int类型，然后左移两位，右侧补0；
  * `bits << 31` 左移31位，左侧超过4字节的部分会被丢弃。
* 右移：>> `unsigned char bit = 0xb5; // 1011 0101`
  * `bits >> 3` 右移3位，右左侧超过4字节的部分会被丢弃，即后面的`101`会被丢弃，变成`10110`。

#### 位逻辑运算符
* 位求反：~
* 位与：&
* 位异或：^
* 位或：|

### 类型转换

#### 隐式类型转换
大多数情况下，C++编译器可以自动对类型进行转换，这种就叫“隐式类型转换”。
思路：长度较小的类型转换成较大的类型，避免精度丢失。 
* 一般长度小的类型会转换成长度较大的；
* 表达式中有整型也有浮点型时，整数值会转换成浮点类型；
* 条件判断语句中，其他的整数类型会转换成布尔类型，0为false，非0为true；
* 初始化变量时，初始值转换成变量的类型；
* 赋值语句中，右侧对象的值会转换成左侧对象的类型；

#### 强制类型转换
求平均数常用。
* C语言风格： (类型)数 => (double)a
* C++风格：类型(数) => double(a)
* C++强制类型转换运算符：static_cast<类型名称>(值) => 

## 流程控制语句
C++流程结构有三种：顺序(默认)、分支和循环，除了默认的顺序，其他两种需要专门的“流程控制语句”来定义。

* 顺序简单语句
```c++
  ; // 空语句
  int a = 10;
  int b = 20;
  int c = a + b;
  cout << c << endl;
```
* 复合语句
```c++
  int i = 0;
  while (i < 5) {
    int a = i;
    i++;
  }
```

### 条件分支
* if语句
  * [单分支](05flow.cpp)
  * [双分支](05flow.cpp)
* switch语句

### 循环
* while：和if区别，while为真时，会一直循环执行
* do while: 和while区别，dowhile至少会执行一次(先执行后判断)，while是先判断后执行；
* **for循环**: for(初始化;条件;表达式)
* 范围f or循环：for(申明：序列表达式) => 数组可以是序列

### 跳转
* break：跳出当前流程控制的语句
* continue：继续执行循环(只能用于循环)
* goto：goto 标签;（灵活且危险，建议慎用）
* return