
## CPP Demo HelloWorld

## 函数
申明头文件，实现函数，对应的文件需要引入头文件

## 变量
* 宏定义(C语言中使用较多)，`.h`文件中定义，一般为全大写(如：`#define PI 3.14159`)
* 常量定义(CPP中常用)，源文件中，一般首字母大写(如：`const float Pi = 3.14159`)
* 变量定义，源文件中，一般首字母小写(如：`float pi = 3.14159`); 可以定义局部和全局变量，全局变量访问(`::pi`)
  * 全局变量可以不用初始化，编译器会帮忙初始化(如： `int a; // 会被编译器默认赋值0`)；
  * 局部变量申明后，在使用前必须初始化，所以推荐申明马上初始化(如：`int a = 10;`)

## 数据类型

### 基本数据类型
申明的时候，只是告诉编译器，申明的变量需要占用多大的空间。

#### 整型(Integer Type)
本质来讲是表示整数的类型。
在计算机中，所有数据都是以二进制0，1来表示的；每个0或1叫做一位(bit);计算机可寻址的内存最小单元是8位，也就是一个字节(Byte)。
我们访问的数据，都是保存在内存的一个个字节里面的。一个字节能表示的最大数是2^8=265。
基本整型包括char(最小8位)、short(最小16位)、int(最小16位，平台不同大小不同)、long(最小32位)，C++11新增long long(最小64位)，布尔类型(未定义，由平台确定)本质也是整型。
不过，int不能比short短，不能比long长，即int的取值范围在[short,long]；一般情况下(win7,win10,macos)，int都是32位，和long一样。

无符号整数，再前面添加unsigned int，short，long就可以。

溢出的原理，与计算机的数据表示有关，涉及到原码、反码、补码的原理。


#### 特殊整型(bool/char)
* char类型
  char：字符，最小尺寸8位(2^8=256)；ASCII编码(用0~127表示128个字符，包括大小写字母、数字、标点符号、特殊符号和一些计算机的控制符)。`char`也有`signed char`和 `unsigned char`
  wchar_t：宽字符类型，底层一般对应另一种整型(short或者int)。C++11中为Unicode字符集提供了专门的拓展字符类型，`char16_t, char32_t`.
* bool类型(真值判断)
  bool类型通常占用8位(一个字节)；取值只有`true、false`；

#### 浮点类型
* float：单精度(一般4字节32位)
* double：双精度(不能小于float，一般8字节64位)
* long double：长双精度(一般12或16个字节)

#### 字面值常量
* 整型字面量
  * 30： 十进制表示法(0-9的数字表示)
  * 036： 八进制表示法(0-7的数字表示)
  * 0x1E：十六进制表示(0-9ABCDEF表示)
  * 上面三个数都是30(十进制)的不同进制表达。
  * 036L
* 浮点字面量
  * 3.14f：float类型
  * 3.14：double类型(默认)
  * 3.14L：long double类型
* 字符(串)字面常量
  * 'C'
  * “ABC”：字符串，本质是一串字符的集合
  * 转义字符：'\''
    * 换行符 \n 
    * 回车符 \r
    * 横向制表符 \t 
    * 报警响铃符 \a 
    * 纵向制表符 \v 
    * 问号 \?
    * 退格符 \b 
    * 反斜线 \\ 
    * 进制符 \f

### 类型转换

#### 赋值时自动类型转换
* bool类型
  * bool b = 25; (底层把所有非零值转成1)
* 浮点与整型转换
  * int a = 3.14; (a = 3)
  * int a = 3.94; (a = 3) ，其实就是小数部分抹掉保留整数部分，带来精度确实
* 整型与整型
  * unsigned short us = 65536； (溢出，us = 0)

## 运算符

### 类型
一元运算符(^取反+-)；+—也可以表示正负
二元运算符(+-*/&|这种)
三元运算符(?:)

### 运算优先级与结合律
平级运算符遵循从左往右依次计算，高一级的预算先计算，和数学的综合表达式类似。
eg：复合表达式：1+2-3*4；先计算3*4=12；1+2-12；然后依次计算。
想要改变优先级，可以使用括号来实现。

### 算术运算
* +、-：正负符号，一元运算符，优先级最高
* */%：乘除取余，二元运算符，优先级次高
* +、-：加减，优先级最低

### 赋值运算符
=，
* 左边必须是可修改的变量(左值)，右边是变量或者常量或者字面量(右值)
* 常量不允许再赋值
* 两侧类型不同时，把右侧对象转换成左侧对象的类型
* 复合赋值运算符
  * 算术运算符：+=、-=、*=、/=、%=
  * 位运算符：<<=、>>=、&=、^=、!=
* 递增递减运算符(自增自减)
  * ++a; ==> a+=1
  * --a; ==> a-=1
  * a++
  * a++和++a的区别： 前置时，对象先加一，再将更新之后的对象值作为结果返回；后置时，对象先将原始值作为结果返回，再加一

### 关系和逻辑运算符

#### 关系运算符
* 大于：`>`
* 大于：`>=`
* 小于：`<`
* 小于等于：`<=`
* 相等：`==`
* 不相等：`!=`

#### 逻辑运算符
与或非
* ！：一元运算符：取反
* &&：二元，全为真才为true
* ||：二元，有一个满足即为真
> 短路求值： i = 0;
> 1<2 && ++i: => i = 1; 前面为真才会执行后面的，因为是&&，但如果前面为false，后面则不会执行
> 1<2 || ++i; => i = 0; 前面为真就直接返回，因为是||
 
### 条件运算符 
三元运算符，`?:`
```c++
  int a = 10;
  int b = 20;
  string c = "";
  
  a > b ? c = "a大于b" : c = "a小于等于b";
  
  cout << c << endl;
 ```

### 位运算符
* 位求反：~
* 左移：<< 
* 右移：>> 
* 位与：&
* 位异或：^
* 位或：|

#### 位运算符
* 左移：<< `unsigned char bit = 0xb5; // 1011 0101`
  * `bits << 2;` 先提升为int类型，然后左移两位，右侧补0；
  * `bits << 31` 左移31位，左侧超过4字节的部分会被丢弃。
* 右移：>> `unsigned char bit = 0xb5; // 1011 0101`
  * `bits >> 3` 右移3位，右左侧超过4字节的部分会被丢弃，即后面的`101`会被丢弃，变成`10110`。

#### 位逻辑运算符
* 位求反：~
* 位与：&
* 位异或：^
* 位或：|

### 类型转换

#### 隐式类型转换
大多数情况下，C++编译器可以自动对类型进行转换，这种就叫“隐式类型转换”。
思路：长度较小的类型转换成较大的类型，避免精度丢失。 
* 一般长度小的类型会转换成长度较大的；
* 表达式中有整型也有浮点型时，整数值会转换成浮点类型；
* 条件判断语句中，其他的整数类型会转换成布尔类型，0为false，非0为true；
* 初始化变量时，初始值转换成变量的类型；
* 赋值语句中，右侧对象的值会转换成左侧对象的类型；

#### 强制类型转换
求平均数常用。
* C语言风格： (类型)数 => (double)a
* C++风格：类型(数) => double(a)
* C++强制类型转换运算符：static_cast<类型名称>(值) => 

## 流程控制语句
C++流程结构有三种：顺序(默认)、分支和循环，除了默认的顺序，其他两种需要专门的“流程控制语句”来定义。

* 顺序简单语句
```c++
  ; // 空语句
  int a = 10;
  int b = 20;
  int c = a + b;
  cout << c << endl;
```
* 复合语句
```c++
  int i = 0;
  while (i < 5) {
    int a = i;
    i++;
  }
```

### 条件分支
* if语句
  * [单分支](05flow.cpp)
  * [双分支](05flow.cpp)
* switch语句

### 循环
* while：和if区别，while为真时，会一直循环执行
* do while: 和while区别，dowhile至少会执行一次(先执行后判断)，while是先判断后执行；
* **for循环**: for(初始化;条件;表达式)
* 范围for循环：for(申明：序列表达式) => 数组可以是序列
  ```c++
  for (int num: {1,2,3,4,5}) {
    // do your logic
  }
  ```

### 跳转
* break：跳出当前流程控制的语句
* continue：继续执行循环(只能用于循环)
* goto：goto 标签;（灵活且危险，建议慎用）
* return

## 复合数据类型
* array
* vector
* string

### 数组
* 定义：数据类型 数组名 [元素个数]；
  * 申明类型，所有元素类型相同；
  * 数组名是标识符，后面跟中括号，里面定义元素个数(即数组长度)；
  * 元素个数也是类型的一部分。
  ```c++
  int arr[10]; // 定义一个数组，名为arr，长度为10；10可以使用const常量替换，但是不能用变量来替换
  
  const int n = 4;
  int a1[n]; // OK
  
  int i = 5;
  // int a2[i]; // not ok!
  
  // 数组的访问：角标
  arr[0]; // 访问第一个元素
  // 数组的遍历=>循环遍历
  for (int num : arr) {
   cout << num << endl;
  }
  ```
* 数组：数组是定长的，申明之后，数组的长度不可以再改变，使用起来也无法直接拿到数组的长度，必须使用`sizeof(arr)/sizeof(arr[0])`来计算。

> 数组尽管很灵活，但是使用起来还是不方便。所以C++定义了扩展的`抽象数据类型(Abstract Data Type, ADT)`,放在标准库中的。


### vector
扩展的数据类型，容器vector，容纳一堆数据对象，即一组相同类型的数据对象的集合。

#### 头文件和命名空间
vector是标准库的一部分，使用前需引入`#include <vector>`,并使用std的命名空间`using namespace std;`.

* 基本用法
```c++
vector<int> v1; // 定义一个叫v1的int类型的vector；默认初始化。

// 列表初始化
vector<char> v2 = {'a', 'b', 'c'};

vector<char> v3{'a','b','c'};
```
#### vector和数组区别
* 数组是更底层的数据类型，长度固定，功能少，安全性无法保证；但是性能更好，运行更高效；
* vector是模板类，是数组的上层抽象；长度不固定，功能强大；缺点是运行效率较低；
* 除了vector，C++11还新增了一个array模板类；和数组类似，长度固定，不过比数组更加方便安全。


### 字符串类型string
字符串即纯文本，各种文字、数字、符号组合在一起表达的一串文本信息。

#### 标准库类型
与vector类似，模板类，定义在std的命名空间中；
* size()内置函数

#### 字符数组（C语言风格）
字符串本质就是字符的数组；C语言中，使用`char[]`来表示字符串，不过为了区分纯粹的`字符数组`和`字符串`;C语言规定，
字符串必须以空字符串(`'0'`)结束,专门用来标记字符串的结尾。

#### 读取输入的字符串
* 输入操作符读取单词 
```c++
string str; 
cin >> str;
cout << str << endl;
// 如果输入hello World，只会输出hello，因为遇到空白符(回车、空格、制表符等)会停止；
// 下面可以读取有一个空白的字符串：
string s1,s2;
cin >> s1 >> s2;
cout << "s1 = " << s1 << endl;
cout << "s2 = " << s2 << endl;
```
* 读取一行信息 `getline`
`getline`有两个参数，一个是输入流对象，另一个是保存字符串的string对象，会一直读取输入流中的内容，直到遇到**换行符**为止。
```c++
string s3;
getline(cin, s3);
cout << "s3 == " << s3 << endl;
```
* 使用get读取字符；
```c++
char c;
ch = cin.get(); // 获取到的字符赋值给c；

cin.get(c); // 直接把c作为参数传给get；
// 上面两个方法也体现了C++的重载。即，cin.get()，可以传参，也可以不传参
// 上面输入再多的字符，打印的也只有一个哦。
```
`get`函数还可以读取一行内容，这种和`getline`类似,也可以。

#### 简单读写文件
C++中专门用于文件的`ifstream(input file stream)`和`ofstream(output file stream)`,对应头文件为`fstream`.


### 结构体struct
和golang的结构体差不多，可以是一种类的抽象，比如学生的结构体，包含了姓名、年龄、性别、班级、成绩这些属性。
* 结构体的申明
```c++
struct 结构体名 {
    类型1 数据对象1；
    类型2 数据对象2；
}
```
不过实际开发中，结构体的定义和创建都是分开进行的。

### 枚举enum
有些变量的取值是有限的几个，使用枚举更加方便。
```c++
enum week {
    // 枚举量，int，从0开始，逐个增大1；
    Mon, Tue, Wed, Thu, Fri, Sat, Sun
}
```

