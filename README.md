
## CPP Demo HelloWorld

## 函数
申明头文件，实现函数，对应的文件需要引入头文件

## 变量
* 宏定义(C语言中使用较多)，`.h`文件中定义，一般为全大写(如：`#define PI 3.14159`)
* 常量定义(CPP中常用)，源文件中，一般首字母大写(如：`const float Pi = 3.14159`)
* 变量定义，源文件中，一般首字母小写(如：`float pi = 3.14159`); 可以定义局部和全局变量，全局变量访问(`::pi`)
  * 全局变量可以不用初始化，编译器会帮忙初始化(如： `int a; // 会被编译器默认赋值0`)；
  * 局部变量申明后，在使用前必须初始化，所以推荐申明马上初始化(如：`int a = 10;`)

## 数据类型

### 基本数据类型
申明的时候，只是告诉编译器，申明的变量需要占用多大的空间。

#### 整型(Integer Type)
本质来讲是表示整数的类型。
在计算机中，所有数据都是以二进制0，1来表示的；每个0或1叫做一位(bit);计算机可寻址的内存最小单元是8位，也就是一个字节(Byte)。
我们访问的数据，都是保存在内存的一个个字节里面的。一个字节能表示的最大数是2^8=265。
基本整型包括char(最小8位)、short(最小16位)、int(最小16位，平台不同大小不同)、long(最小32位)，C++11新增long long(最小64位)，布尔类型(未定义，由平台确定)本质也是整型。
不过，int不能比short短，不能比long长，即int的取值范围在[short,long]；一般情况下(win7,win10,macos)，int都是32位，和long一样。

无符号整数，再前面添加unsigned int，short，long就可以。

溢出的原理，与计算机的数据表示有关，涉及到原码、反码、补码的原理。


#### 特殊整型(bool/char)
* char类型
  char：字符，最小尺寸8位(2^8=256)；ASCII编码(用0~127表示128个字符，包括大小写字母、数字、标点符号、特殊符号和一些计算机的控制符)。`char`也有`signed char`和 `unsigned char`
  wchar_t：宽字符类型，底层一般对应另一种整型(short或者int)。C++11中为Unicode字符集提供了专门的拓展字符类型，`char16_t, char32_t`.
* bool类型(真值判断)
  bool类型通常占用8位(一个字节)；取值只有`true、false`；

#### 浮点类型
* float：单精度(一般4字节32位)
* double：双精度(不能小于float，一般8字节64位)
* long double：长双精度(一般12或16个字节)

#### 字面值常量
* 整型字面量
  * 30： 十进制表示法(0-9的数字表示)
  * 036： 八进制表示法(0-7的数字表示)
  * 0x1E：十六进制表示(0-9ABCDEF表示)
  * 上面三个数都是30(十进制)的不同进制表达。
  * 036L
* 浮点字面量
  * 3.14f：float类型
  * 3.14：double类型(默认)
  * 3.14L：long double类型
* 字符(串)字面常量
  * 'C'
  * “ABC”：字符串，本质是一串字符的集合
  * 转义字符：'\''
    * 换行符 \n 
    * 回车符 \r
    * 横向制表符 \t 
    * 报警响铃符 \a 
    * 纵向制表符 \v 
    * 问号 \?
    * 退格符 \b 
    * 反斜线 \\ 
    * 进制符 \f

### 类型转换

#### 赋值时自动类型转换
* bool类型
  * bool b = 25; (底层把所有非零值转成1)
* 浮点与整型转换
  * int a = 3.14; (a = 3)
  * int a = 3.94; (a = 3) ，其实就是小数部分抹掉保留整数部分，带来精度确实
* 整型与整型
  * unsigned short us = 65536； (溢出，us = 0)

## 运算符

### 类型
一元运算符(^取反+-)；+—也可以表示正负
二元运算符(+-*/&|这种)
三元运算符(?:)

### 运算优先级与结合律
平级运算符遵循从左往右依次计算，高一级的预算先计算，和数学的综合表达式类似。
eg：复合表达式：1+2-3*4；先计算3*4=12；1+2-12；然后依次计算。
想要改变优先级，可以使用括号来实现。

### 算术运算
* +、-：正负符号，一元运算符，优先级最高
* */%：乘除取余，二元运算符，优先级次高
* +、-：加减，优先级最低

### 赋值运算符
=，
* 左边必须是可修改的变量(左值)，右边是变量或者常量或者字面量(右值)
* 常量不允许再赋值
* 两侧类型不同时，把右侧对象转换成左侧对象的类型
* 复合赋值运算符
  * 算术运算符：+=、-=、*=、/=、%=
  * 位运算符：<<=、>>=、&=、^=、!=
* 递增递减运算符(自增自减)
  * ++a; ==> a+=1
  * --a; ==> a-=1
  * a++
  * a++和++a的区别： 前置时，对象先加一，再将更新之后的对象值作为结果返回；后置时，对象先将原始值作为结果返回，再加一

### 关系和逻辑运算符

#### 关系运算符
* 大于：`>`
* 大于：`>=`
* 小于：`<`
* 小于等于：`<=`
* 相等：`==`
* 不相等：`!=`

#### 逻辑运算符
与或非
* ！：一元运算符：取反
* &&：二元，全为真才为true
* ||：二元，有一个满足即为真
> 短路求值： i = 0;
> 1<2 && ++i: => i = 1; 前面为真才会执行后面的，因为是&&，但如果前面为false，后面则不会执行
> 1<2 || ++i; => i = 0; 前面为真就直接返回，因为是||
 
### 条件运算符 
三元运算符，`?:`
```c++
  int a = 10;
  int b = 20;
  string c = "";
  
  a > b ? c = "a大于b" : c = "a小于等于b";
  
  cout << c << endl;
 ```

### 位运算符
* 位求反：~
* 左移：<< 
* 右移：>> 
* 位与：&
* 位异或：^
* 位或：|

#### 位运算符
* 左移：<< `unsigned char bit = 0xb5; // 1011 0101`
  * `bits << 2;` 先提升为int类型，然后左移两位，右侧补0；
  * `bits << 31` 左移31位，左侧超过4字节的部分会被丢弃。
* 右移：>> `unsigned char bit = 0xb5; // 1011 0101`
  * `bits >> 3` 右移3位，右左侧超过4字节的部分会被丢弃，即后面的`101`会被丢弃，变成`10110`。

#### 位逻辑运算符
* 位求反：~
* 位与：&
* 位异或：^
* 位或：|

### 类型转换

#### 隐式类型转换
大多数情况下，C++编译器可以自动对类型进行转换，这种就叫“隐式类型转换”。
思路：长度较小的类型转换成较大的类型，避免精度丢失。 
* 一般长度小的类型会转换成长度较大的；
* 表达式中有整型也有浮点型时，整数值会转换成浮点类型；
* 条件判断语句中，其他的整数类型会转换成布尔类型，0为false，非0为true；
* 初始化变量时，初始值转换成变量的类型；
* 赋值语句中，右侧对象的值会转换成左侧对象的类型；

#### 强制类型转换
求平均数常用。
* C语言风格： (类型)数 => (double)a
* C++风格：类型(数) => double(a)
* C++强制类型转换运算符：static_cast<类型名称>(值) => 

## 流程控制语句
C++流程结构有三种：顺序(默认)、分支和循环，除了默认的顺序，其他两种需要专门的“流程控制语句”来定义。

* 顺序简单语句
```c++
  ; // 空语句
  int a = 10;
  int b = 20;
  int c = a + b;
  cout << c << endl;
```
* 复合语句
```c++
  int i = 0;
  while (i < 5) {
    int a = i;
    i++;
  }
```

### 条件分支
* if语句
  * [单分支](05flow.cpp)
  * [双分支](05flow.cpp)
* switch语句

### 循环
* while：和if区别，while为真时，会一直循环执行
* do while: 和while区别，dowhile至少会执行一次(先执行后判断)，while是先判断后执行；
* **for循环**: for(初始化;条件;表达式)
* 范围for循环：for(申明：序列表达式) => 数组可以是序列
  ```c++
  for (int num: {1,2,3,4,5}) {
    // do your logic
  }
  ```

### 跳转
* break：跳出当前流程控制的语句
* continue：继续执行循环(只能用于循环)
* goto：goto 标签;（灵活且危险，建议慎用）
* return

## 复合数据类型
* array
* vector
* string

### 数组
* 定义：数据类型 数组名 [元素个数]；
  * 申明类型，所有元素类型相同；
  * 数组名是标识符，后面跟中括号，里面定义元素个数(即数组长度)；
  * 元素个数也是类型的一部分。
  ```c++
  int arr[10]; // 定义一个数组，名为arr，长度为10；10可以使用const常量替换，但是不能用变量来替换
  
  const int n = 4;
  int a1[n]; // OK
  
  int i = 5;
  // int a2[i]; // not ok!
  
  // 数组的访问：角标
  arr[0]; // 访问第一个元素
  // 数组的遍历=>循环遍历
  for (int num : arr) {
   cout << num << endl;
  }
  ```
* 数组：数组是定长的，申明之后，数组的长度不可以再改变，使用起来也无法直接拿到数组的长度，必须使用`sizeof(arr)/sizeof(arr[0])`来计算。

> 数组尽管很灵活，但是使用起来还是不方便。所以C++定义了扩展的`抽象数据类型(Abstract Data Type, ADT)`,放在标准库中的。

### vector
扩展的数据类型，容器vector，容纳一堆数据对象，即一组相同类型的数据对象的集合。

#### 头文件和命名空间
vector是标准库的一部分，使用前需引入`#include <vector>`,并使用std的命名空间`using namespace std;`.

* 基本用法
```c++
vector<int> v1; // 定义一个叫v1的int类型的vector；默认初始化。

// 列表初始化
vector<char> v2 = {'a', 'b', 'c'};

vector<char> v3{'a','b','c'};
```
#### vector和数组区别
* 数组是更底层的数据类型，长度固定，功能少，安全性无法保证；但是性能更好，运行更高效；
* vector是模板类，是数组的上层抽象；长度不固定，功能强大；缺点是运行效率较低；
* 除了vector，C++11还新增了一个array模板类；和数组类似，长度固定，不过比数组更加方便安全。

### 字符串类型string
字符串即纯文本，各种文字、数字、符号组合在一起表达的一串文本信息。

#### 标准库类型
与vector类似，模板类，定义在std的命名空间中；
* size()内置函数

#### 字符数组（C语言风格）
字符串本质就是字符的数组；C语言中，使用`char[]`来表示字符串，不过为了区分纯粹的`字符数组`和`字符串`;C语言规定，
字符串必须以空字符串(`'0'`)结束,专门用来标记字符串的结尾。

#### 读取输入的字符串
* 输入操作符读取单词 
```c++
string str; 
cin >> str;
cout << str << endl;
// 如果输入hello World，只会输出hello，因为遇到空白符(回车、空格、制表符等)会停止；
// 下面可以读取有一个空白的字符串：
string s1,s2;
cin >> s1 >> s2;
cout << "s1 = " << s1 << endl;
cout << "s2 = " << s2 << endl;
```
* 读取一行信息 `getline`
`getline`有两个参数，一个是输入流对象，另一个是保存字符串的string对象，会一直读取输入流中的内容，直到遇到**换行符**为止。
```c++
string s3;
getline(cin, s3);
cout << "s3 == " << s3 << endl;
```
* 使用get读取字符；
```c++
char c;
ch = cin.get(); // 获取到的字符赋值给c；

cin.get(c); // 直接把c作为参数传给get；
// 上面两个方法也体现了C++的重载。即，cin.get()，可以传参，也可以不传参
// 上面输入再多的字符，打印的也只有一个哦。
```
`get`函数还可以读取一行内容，这种和`getline`类似,也可以。

#### 简单读写文件
C++中专门用于文件的`ifstream(input file stream)`和`ofstream(output file stream)`,对应头文件为`fstream`.

### 结构体struct
和golang的结构体差不多，可以是一种类的抽象，比如学生的结构体，包含了姓名、年龄、性别、班级、成绩这些属性。
* 结构体的申明
```c++
struct 结构体名 {
    类型1 数据对象1；
    类型2 数据对象2；
}
```
不过实际开发中，结构体的定义和创建都是分开进行的。

### 枚举enum
有些变量的取值是有限的几个，使用枚举更加方便。
```c++
enum week {
    // 枚举量，int，从0开始，逐个增大1；
    Mon, Tue, Wed, Thu, Fri, Sat, Sun
}
```

### 指针
计算机的数据都存放在内存中，访问内存的最小单元室字节(byte)，所有数据，就保存在内存中具有连续编号的一串字节里。

指针顾名思义，是指向另外一种数据类型的复合类型。指针是C/C++中一种特殊的数据类型，是另一个数据对象在内存中的地址；
通过指针可以访问到指向的那个数据对象，所以是一种间接访问对象的方法。

* 定义
  语法形式：`类型* 指针变量`；
  这里的类型是指针所指向的数据类型，后面加*号，再跟上类型的名称。
  指针本质是一个整数表示的内存地址，在内存中的所占大小和系统有关，和数据类型无关。
  64位操作系统，指针8个字节；32位操作系统，指针4个字节。
* 使用
  * 申明指针
  * 通过指针访问对象,解引用操作符(`*`)
* 空指针
  * 空指针
  ```c++
    int* np = nullptr; // 空指针，但是有类型
    np = NULL; // 宏定义的空指针
    np = 0; // 指向0地址的空指针。
  ```
  * void* 指针
  一般来说，指针的类型必须和指向的对象类型匹配，否则会报错，不过`void*`很特殊，可以用来存放任意对象的地址。
* 指针的指针
  拿来套娃的，指针的指针，解两次引用才能访问到具体的值；
* 指针与const结合
  指针可以和const修饰符结合，可以有两种形式，一种是指针指向的是一个常量；另一种是指针本身是一个常量；
  * 指向常量的指针：
  ```c++
    const int c1 = 10, c2 = 20;
    const int* cp = &c1; // 
    cp = &c2;
  ```
  > cp本身是一个指向常量的变量，其本质还是一个变量，所以cp可以指向任意常量；不过一旦指向一个常量后，不能对对应的常量做修改；
  * 指针常量：
  ```c++
    int i = 10;
    int* const cp = &i; // 指针常量，即cp是指针常量，一旦绑定后不可再修改，和常量一样；
    *cp = 200;  // 但是指针指向的是一个变量，所以可以对指向的变量进行修改;有点绕是吧，哈哈哈
  ```
  > cp是一个指向指针的常量，本质上就是一个常量，所以cp不允许再修改；但是可以修改指向的那个变量的值；
* 指针和数组 
  * 数组(数组名)本质是一块连续的内存空间，存放相同类型的数据。所以数组只保存第一个元素的地址，其他元素的地址可以根据首地址+类型来快速寻址。
  * 指针运算
    本质上是访问指针指向类型的数组的下一个元素，所以`+1`实际上是对指针加上了对应类型的长度，跳到下一个元素；
    ```c++
      int arr[] = {1,2,3,4,5};
      int pia = &arr; // 指向数组的第一个元素
      *pia = 128;// arr[] = {128, 2,3,4,5};
      *(pia+1) = 256; // 即把第二个元素改成256，arr[] = {128,256,3,4,5};
    ```
  * 数组指针
    本质是指针，是数组的指针。
  * 指针数组
    本质是数组，元素是指针的数组

### 引用
C++中，数据对象有一个另外的名字：引用(reference).

> 引用必须要初始化

### 引用和指针
有很多类似的地方，常量引用和常量指针都可以绑定/指向一个常量，也可以绑定/指向一个变量，但是不能修改对应的变量；
* 引用和指针常量
  引用的行为，非常类似于“指针常量”，也就是指向唯一的对象，不能更改的指针；引用只是一个语法糖。
* 引用的本质
  引用类似于指针常量，但是不同于指针常量；
  引用只是一个别名，不占内存；引用只是C++引入的一个语法糖，是对指针的一种伪装。
  指针是C语言中最灵活最强大的特性，引用能做的指针完全可以替代；只是指针比较复杂，操作起来比较危险，所以C++引入了引用。

## 函数

### 函数定义
函数是实现了某个功能的特定模块，一个完整的函数定义主要包括以下部分：
* 返回类型；
* 函数名
* 参数列表()，一般叫形参，放小括号里，0个或多个；
* 函数体{};
```c++
// 定义函数，square，求一个数的平方。
int square(int x) {
    int y = x*x;
    return y;
}
```
* 函数调用
* 函数变量生命周期
> 注意：C++中，作用域指的是变量名字的可见范围；变量不可见，不代表变量所指代的数据对象就销毁了，所以有作用域和生命周期
* 作用域：针对名字而言，是程序文本的一部分，名字在这部分可见；
  * 局部变量：在函数体内和函数的形参；
  * 全局变量：全局有效；
* 生命周期：针对数据对象而言，是程序在执行过程中，对象从创建到销毁的时间段；
  * 自动对象：代码中定义的局部变量；在程序执行到变量定义语句时创建，运行到当前块末尾时销毁，称为自动对象；形参也是一种自动对象；
  * 静态对象：如果希望延长一个局部变量的生命周期，让其在作用域外依然保留，在局部变量前面加关键词`static`，这种对象叫`局部静态对象`。
    局部静态对象只有局部的作用域，在块外依然是不可见的；但是它的生命周期贯穿整个运行过程。
* 函数申明
```c++
int square(int); // 可以省略形参名字
```
* 编译：C++可以分离式编译和头文件。

### 参数传递
引用传递和值传递
```c++
int i1 = 10;

int i2 = i1; // 值拷贝，改变i1不会影响i2；改变i2不会影响i1；
 
int& i3 = i1; // 引用拷贝，改变i3会改变i1的值；
```
* 函数的值传递
```c++
int square(int x) {
    return x*x;
}
int main() {
    int n = 6;
    cout << n << "的平方是：" << square(6) << endl;
}
```
* 可变形参...
* 返回值
```c++
  const string& func() {
    string str = "test";
    return str;
  }
```
> 上面做法非常不安全，str是函数的局部对象，函数执行完成后就销毁了；而返回值是它的引用，就相当于引用了一个不存在的对象，就会导致意想不到的问题；
* 返回数组指针
  
#### 递归
函数调用自身，这样的函数叫`递归函数`。一般递归也可以使用`for`循环来实现。
递归需要额外的栈空间开销，所以比循环效率低一点，但是在很多很多数学问题上，递归可以让代码非常简洁。
* 阶乘函数
* 斐波那契数列

### 函数高阶
函数是模块化编程思想的重要体现。

#### 内联函数
为了提高运行速度做的优化；即把函数调用的代码直接替换为实现的代码，减少了函数的跳转和上下文维护；
C语言中类似功能可以使用预处理语句`#define`定义`宏`来实现；但是C中的宏本质是文本替换，实现函数的功能会很麻烦，可读性会很差。
关键字：`inline`
```c++
inline int add(int a, int b) {
    return a + b;
}
```
#### 默认实参
会反复出现的默认值，称为函数的`默认实参`，当调用一个有默认实参的函数时，实参可以省略(Python中也是)。
```c++
string stuInfo(string name = "", int age = 18, double score = 60) {
    string info = "学生姓名：" + name + "\t年龄：" + to_string(age) + "\t平均成绩：" + to_string(score);
    
    return info;
}
```
> 一旦一个参数定义为实参之后，后面所有的参数都必须定义为实参，否则编译会报错；

#### 函数重载
C++中，统一作用域下，同一个函数名可以定义多次，前提是形参列表不同，这种函数就叫`重载函数`。
```c++
void increase(int* p) {
    ++(*p);
}
void increase(int& p) {
    ++p;
}
```
调用的函数根据参数来匹配。
* 有const形参时的重载
  * `顶层const`不可进行重载；
  ```c++
  void fun(int i);
  // 使用常量作为形参，跟不加const完全等价，因为是值传递的，
  //void fun(const int i);
  void fun2(int* p);
  // 指针常量其实也是常量，和不加const也是等价的；
  //void fun2(int* const pc);
  ```
  * 引用和指针const
  ```c++
  // 常量引用和引用
  void fun3(int& i);
  void fun3(const int& x);
  
  // 常量指针和指针
  void fun4(int* p);
  void fun4(const int* p);
  ```
  
#### 函数匹配
调用函数时，传入的实参跟形参类型不同，只要能通过隐式类型转换变成需要的类型，也可以正确调用，确定调用哪个函数的这个过程就叫函数的匹配。
```c++
void f() {cout << 1 << endl;} // 1
void f(int x){cout << 2 << endl;} // 2
void f(int x, int y){cout << 3 << endl;} // 3
void f(double x, double y = 1.5){cout << 4 << endl;} // 4

f(3.14);  // 应该调用的是哪个函数？ ==> 输出4； 
// 即哪个函数匹配的优先级更高？
``` 
* 候选函数：第一步确定候选函数，1.与调用函数同名；2.函数的申明，在调用点事可见的； => 4个都可以
* 可行函数：第二部，跟传入的实参匹配；1.形参个数与调用传入的实参数量相等；2.每个实参的类型与对应的形参类型相同，或者可以转换成同类型的实参； ==> 2，4都可以 
* 最佳匹配：实参类型与形参类型越接近，匹配越好；即能不进行转换就实际匹配的，要优于需要转换的；
* 多参数的函数匹配：实参数量不止一个的话，就需要逐个比较；同理，类型精确匹配优于需要转换的；
* 二义性调用：检车完所有实参之后，有多个可行函数不分优劣，无法找到一个最佳匹配，编译器会直接报错，这被称为`二义性调用`.
```c++
f(10, 3.14); // 二义性调用，3，4同时都满足，编译器无法确定到底调用谁；
```

#### 重载与作用域
其实与变量的作用域类似，就近原则。


### 函数指针
一类特殊的指针，指向的不是数据对象而是函数。指向函数的指针。

#### 申明函数指针

```c++
// 打印学生信息
string printStuInfo(string name, int age, double score) {
    return "姓名：" + name + "\t年龄：" + to_string(age) + "\t平均成绩：" + to_string(score);
}
```
上面函数的类型就是：`string(string, int, double)`
如果要申明一个指向它的指针，只要把原先函数名的位置填上指针即可；
`string(* fp)(string, int, double)`,注意，指针两侧的括号不能少，少了就变成出参是指向字符串的指针类型了`string* fp(string, int, double)`。


#### 函数指针作为形参
在函数调用时，满足条件的时候调用传入的函数指针，这个时候参数就需要对应的函数指针。

#### 函数指针作为返回值
在函数调用时，满足条件的时候调用传入的函数指针，这个时候参数就需要对应的函数指针。

